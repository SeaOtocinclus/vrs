---
sidebar_position: 1
title: Overview
---

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

VRS is a **file format** optimized to record and playback streams of sensor data, such as images, audio samples, and other discrete sensors (IMU, temperature, etc.), that are stored in per-device streams of time-stamped records.

VRS was first created to record images and sensor data from early prototypes of the Quest device, to develop the deviceâ€™s positional tracking system, now known as [Insight](https://ai.facebook.com/blog/powered-by-ai-oculus-insight/), and Quest's hand tracking software. VRS is also the file format used by the [Aria glasses](https://about.facebook.com/realitylabs/projectaria/).

## Appropriate Use Cases

VRS is designed to record similar looking bundles of data produced repeatedly over a period of time, in time-stamped records.

<Tabs>

  <TabItem value="good_cases" label="Valid Use Cases" default>
VRS is well suited to record and playback:
<li>Data produced by the cameras and sensors of a Quest device, including IMUs.</li>
<li>Data produced by the cameras and sensors of an Aria device, including positional tracking cameras, eye tracking cameras, barometer sensors, GPS and BT beacons, multi-channel audio.</li>
<li>Data produced in burst of activity, such as keyboard or mouse input data.</li>
<li>TCP/IP or USB packets.</li>
  </TabItem>

  <TabItem value="bad_cases" label="Invalid Use Cases">
VRS is not a good choice to record anything without temporal information or data format regularity, such as:
<li>A text document.</li>
<li>A web page.</li>
<li>A point cloud.</li>
<li>A 3D model.</li>
<li>A single image with annotations.</li>
  </TabItem>

</Tabs>

<!-- prettier-ignore -->
:::info
While VRS is very effective at streaming very large amounts of data to disk, potentially to and from cloud storage, with real-time lossless compression, creating files potentially very large (typical VRS files range from 5 to 80 GB, but 1.5 TB VRS files exist), editing VRS files is not nearly as convenient, as the entire container typically needs to be rewritten.
:::

## Data Types and Data Conventions

VRS provides standardized methods to store images, audio, and discrete sensors data in compact and format evolution resilient records, so you can save data without having to worry too much about evolving requirements. But while VRS standardizes how to save common data types, VRS does not prescribe how to address specific use cases. Data format conventions are desirable, to enable teams working on identical or similar use cases to exchange data. However, such data format conventions are out of the scope of VRS.

## Main features

- VRS files contain multiple streams of time-sorted records generated by a set of _devices_, typically one set of _devices_ per stream.
- A file and its streams contain a set of _tags_, which are string name/value pairs that describe them.
- Streams may contain `Configuration`, `State` and `Data` records, each with a timestamp in a common time domain for the whole file. Typically, streams contain one `Configuration` record and one `State` record, followed by one to millions of `Data` records.
- Records are structured as a succession of typed content blocks. Typically, content blocks are metadata, image, audio, and custom content blocks.
- Metadata content blocks contain raw sensor data described once per stream, making the file format very efficient. The marginal cost of adding 1 byte of data to each metadata content block in a stream is 1 byte per record (or less when lossless compression happens).
- Records can be losslessly compressed using lz4 or zstd, which are fast enough to do lossless compression during recording.
- Multiple threads can create records concurrently for the same file.
- VRS supports huge file sizes (tested with multi-terabyte use cases).
- VRS supports chunked files: auto-chunking on creation and automated chunk detection for playback.
- Playback is optimized for timestamp ordering, which is key for network streaming.
- Random-access playback is fully supported in memory files and stream indexes.
- Customizable `FileHandler` support to implement streaming from cloud storage is not currently provided.
